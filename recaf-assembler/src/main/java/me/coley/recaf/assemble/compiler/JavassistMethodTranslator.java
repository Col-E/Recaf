package me.coley.recaf.assemble.compiler;

import javassist.CannotCompileException;
import javassist.CtClass;
import javassist.bytecode.*;
import me.coley.recaf.util.JavassistUtil;
import me.coley.recaf.util.OpcodeUtil;
import org.objectweb.asm.tree.AbstractInsnNode;

import java.util.HashSet;
import java.util.Set;

/**
 * Allows translation of generated bytecode from Javassist by exposing each generated instruction in a visitor pattern.
 *
 * @author Matt Coley
 */
public class JavassistMethodTranslator {
	private final Set<Integer> labelOffsets = new HashSet<>();

	/**
	 * Translates the given code depending on the implementation.
	 *
	 * @param clazz
	 * 		Owner type of code being written.
	 * @param code
	 * 		Code to translate.
	 *
	 * @throws CannotCompileException
	 * 		When the code cannot be compiled due to syntax or resolution errors.
	 * @throws BadBytecode
	 * 		When the code generated is malformed.
	 */
	public void visit(CtClass clazz, CodeAttribute code) throws CannotCompileException, BadBytecode {
		populateControlFlowTargets(code);
		iterateCode(clazz, code.iterator());
		iterateTryCatch(clazz, code.getExceptionTable());
	}

	private void populateControlFlowTargets(CodeAttribute code) throws BadBytecode {
		// Method bounds
		labelOffsets.add(0);
		labelOffsets.add(code.getCodeLength());
		// Handle instructions (jumps/switches)
		CodeIterator iterator = code.iterator();
		while (iterator.hasNext())
			populateLabels(iterator);
		// Handle try-catch blocks
		ExceptionTable table = code.getExceptionTable();
		for (int entry = 0; entry < table.size(); entry++) {
			int start = table.startPc(entry);
			int end = table.endPc(entry);
			int handler = table.handlerPc(entry);
			labelOffsets.add(start);
			labelOffsets.add(end);
			labelOffsets.add(handler);
		}
	}

	private void iterateCode(CtClass clazz, CodeIterator iterator) throws CannotCompileException, BadBytecode {
		visitBranchDestination(0);
		while (iterator.hasNext())
			handleNextInsn(clazz, iterator);
		visitBranchDestination(iterator.getCodeLength());
	}

	private void iterateTryCatch(CtClass clazz, ExceptionTable table) {
		for (int entry = 0; entry < table.size(); entry++) {
			int start = table.startPc(entry);
			int end = table.endPc(entry);
			int handler = table.handlerPc(entry);
			int typeCp = table.catchType(entry);
			ConstPool cp = clazz.getClassFile().getConstPool();
			String typeName = null;
			try {
				typeName = JavassistUtil.getInternalName(clazz, typeCp);
			} catch (ReflectiveOperationException e) {
				typeName = cp.getClassInfo(typeCp).replace('.', '/');
			}
			// Do not need to visit the branch destinations, that is handled in the per-insn visit.
			// But we do need to visit the try-catch block attribute entries
			visitTryCatch(start, end, handler, typeName);
		}
	}

	private void populateLabels(CodeIterator iterator) throws BadBytecode {
		int pos = iterator.next();
		int op = iterator.byteAt(pos);
		int type;
		try {
			type = OpcodeUtil.opcodeToType(op);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + op);
		}
		if (type == AbstractInsnNode.JUMP_INSN) {
			int offset = getJumpOffset(op, pos, iterator);
			labelOffsets.add(offset);
		} else if (type == AbstractInsnNode.LOOKUPSWITCH_INSN) {
			int switchStart = pos;
			// Skip 0 to 3 padding bytes.
			pos += 4 - (pos & 3);
			// Read the default label.
			int dflt = switchStart + iterator.s32bitAt(pos);
			// Read the number of table entries.
			pos += 4;
			int numEntries = iterator.s32bitAt(pos);
			int[] pcs = new int[numEntries];
			for (int i = 0; i < numEntries; i++) {
				// Skip over 'key' value int
				pos += 4;
				// Get PC associated with key
				pos += 4;
				int pc = switchStart + iterator.s32bitAt(pos);
				pcs[i] = pc;
			}
			labelOffsets.add(dflt);
			for (int pc : pcs)
				labelOffsets.add(pc);
		} else if (type == AbstractInsnNode.TABLESWITCH_INSN) {
			int switchStart = pos;
			// Skip 0 to 3 padding bytes.
			pos += 4 - (pos & 3);
			// Read the default label.
			int dflt = switchStart + iterator.s32bitAt(pos);
			// Read the range
			pos += 4;
			int min = iterator.s32bitAt(pos);
			pos += 4;
			int max = iterator.s32bitAt(pos);
			int numEntries = max - min + 1;
			// Read the offsets
			int[] pcs = new int[numEntries];
			for (int i = 0; i < numEntries; i++) {
				// Get PC associated with key (derived from range)
				pos += 4;
				int pc = switchStart + iterator.s32bitAt(pos);
				pcs[i] = pc;
			}
			labelOffsets.add(dflt);
			for (int pc : pcs)
				labelOffsets.add(pc);
		}
	}

	private void handleNextInsn(CtClass clazz, CodeIterator iterator)
			throws CannotCompileException, BadBytecode {
		int pos = iterator.next();
		if (pos != 0 && labelOffsets.contains(pos))
			visitBranchDestination(pos);
		int op = iterator.byteAt(pos);
		ConstPool cp = clazz.getClassFile().getConstPool();
		int type;
		try {
			type = OpcodeUtil.opcodeToType(op);
		} catch (NullPointerException e) {
			throw new IllegalStateException("Unhandled op: " + op);
		}
		switch (type) {
			case AbstractInsnNode.INSN:
				visitInsn(op);
				break;
			case AbstractInsnNode.INT_INSN: {
				int value;
				if (op == Opcode.BIPUSH || op == Opcode.NEWARRAY) {
					value = iterator.byteAt(pos + 1);
				} else if (op == Opcode.SIPUSH) {
					value = iterator.s16bitAt(pos + 1);
				} else {
					throw new BadBytecode("Unknown int insn: " + op);
				}
				visitInt(op, value);
				break;
			}
			case AbstractInsnNode.VAR_INSN: {
				int index;
				if (OpcodeUtil.deindexVarOp(op) != op) {
					index = OpcodeUtil.indexFromVarOp(op);
				} else {
					index = iterator.byteAt(pos + 1);
				}
				visitVar(op, index);
				break;
			}
			case AbstractInsnNode.TYPE_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String name = Descriptor.toJvmName(cp.getClassInfo(index));
				visitType(op, name);
				break;
			}
			case AbstractInsnNode.FIELD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				String owner = Descriptor.toJvmName(cp.getFieldrefClassName(index));
				String name = cp.getFieldrefName(index);
				String signature = cp.getFieldrefType(index);
				visitField(op, owner, name, signature);
				break;
			}
			case AbstractInsnNode.METHOD_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int nameType;
				if (op == Opcode.INVOKEINTERFACE)
					nameType = cp.getInterfaceMethodrefNameAndType(index);
				else
					nameType = cp.getMethodrefNameAndType(index);
				String owner = Descriptor.toJvmName(cp.getMethodrefClassName(index));
				String name = cp.getUtf8Info(cp.getNameAndTypeName(nameType));
				String signature = cp.getUtf8Info(cp.getNameAndTypeDescriptor(nameType));
				visitMethod(op, owner, name, signature);
				break;
			}
			case AbstractInsnNode.IINC_INSN: {
				int index = iterator.byteAt(pos + 1);
				int incr = iterator.signedByteAt(pos + 2);
				visitIinc(op, index, incr);
				break;
			}
			case AbstractInsnNode.LDC_INSN: {
				int index;
				if (op == Opcode.LDC)
					index = iterator.byteAt(pos + 1);
				else
					index = iterator.u16bitAt(pos + 1);
				Object value = cp.getLdcValue(index);
				visitLdc(op, value);
				break;
			}
			case AbstractInsnNode.MULTIANEWARRAY_INSN: {
				int index = iterator.u16bitAt(pos + 1);
				int dimensions = iterator.byteAt(pos + 3);
				String elementType = cp.getClassInfo(index);
				visitMultiANewArray(op, elementType, dimensions);
				break;
			}
			case AbstractInsnNode.INVOKE_DYNAMIC_INSN:
				// I don't think Javassist is even capable of outputting INDY
				throw new CannotCompileException("Invoke dynamic instructions not supported");
			case AbstractInsnNode.JUMP_INSN:
				int offset = getJumpOffset(op, pos, iterator);
				visitJump(op, offset);
				break;
			case AbstractInsnNode.LOOKUPSWITCH_INSN: {
				int switchStart = pos;
				// Skip 0 to 3 padding bytes.
				pos += 4 - (pos & 3);
				// Read the default label.
				int dflt = switchStart + iterator.s32bitAt(pos);
				// Read the number of table entries.
				pos += 4;
				int numEntries = iterator.s32bitAt(pos);
				int[] keys = new int[numEntries];
				int[] pcs = new int[numEntries];
				for (int i = 0; i < numEntries; i++) {
					pos += 4;
					int key = iterator.s32bitAt(pos);
					keys[i] = key;
					pos += 4;
					int pc = switchStart + iterator.s32bitAt(pos);
					pcs[i] = pc;
				}
				visitLookupSwitch(op, dflt, keys, pcs);
				break;
			}
			case AbstractInsnNode.TABLESWITCH_INSN: {
				int switchStart = pos;
				// Skip 0 to 3 padding bytes.
				pos += 4 - (pos & 3);
				// Read the default label.
				int dflt = switchStart + iterator.s32bitAt(pos);
				// Read the range
				pos += 4;
				int min = iterator.s32bitAt(pos);
				pos += 4;
				int max = iterator.s32bitAt(pos);
				int numEntries = max - min + 1;
				// Read the offsets
				int[] pcs = new int[numEntries];
				for (int i = 0; i < numEntries; i++) {
					// Get PC associated with key (derived from range)
					pos += 4;
					int pc = switchStart + iterator.s32bitAt(pos);
					pcs[i] = pc;
				}
				visitTableSwitch(op, dflt, min, max, pcs);
				break;
			}
			default:
				throw new CannotCompileException("Unhandled instruction type for opcode: " + op);
		}
	}

	private int getJumpOffset(int op, int pos, CodeIterator iterator) {
		if (op == Opcode.GOTO_W)
			return pos + iterator.s32bitAt(pos + 1);
		else
			return pos + iterator.s16bitAt(pos + 1);
	}

	/// ================== Below are stubs for children to implement ================== ///

	/**
	 * Visit a control flow destination.
	 *
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitBranchDestination(int offset) {
	}

	/**
	 * Visit a try-catch block.
	 *
	 * @param start
	 * 		Absolute offset in the method code for the start of the try block.
	 * @param end
	 * 		Absolute offset in the method code for the end of the try block.
	 * @param handler
	 * 		Absolute offset in the method code for the start of the handler block.
	 * @param typeName
	 * 		Handler exception type.
	 */
	public void visitTryCatch(int start, int end, int handler, String typeName) {
	}

	/**
	 * Visit a jump instruction.
	 *
	 * @param opcode
	 * 		Jump instruction opcode.
	 * @param offset
	 * 		Absolute offset in the method code for the destination.
	 */
	public void visitJump(int opcode, int offset) {
	}

	/**
	 * Visit a lookup switch instruction.
	 *
	 * @param opcode
	 * 		Lookup switch opcode.
	 * @param defaultPc
	 * 		Default PC.
	 * @param keys
	 * 		Key values.
	 * @param pcs
	 * 		Associated PC offsets to keys.
	 */
	public void visitLookupSwitch(int opcode, int defaultPc, int[] keys, int[] pcs) {
	}

	/**
	 * Visit a table switch instruction.
	 *
	 * @param opcode
	 * 		Lookup switch opcode.
	 * @param defaultPc
	 * 		Default PC.
	 * @param min
	 * 		Range minimum.
	 * @param max
	 * 		Range maximum.
	 * @param pcs
	 * 		Associated PC offsets to range values.
	 */
	public void visitTableSwitch(int opcode, int defaultPc, int min, int max, int[] pcs) {
	}

	/**
	 * Visit an {@code MULTIANEWARRAY} instruction.
	 *
	 * @param opcode
	 *        {@code MULTIANEWARRAY}
	 * @param type
	 * 		Object type.
	 * @param dimensions
	 * 		Number of dimentsions.
	 */
	public void visitMultiANewArray(int opcode, String type, int dimensions) {
	}

	/**
	 * Visit a load-constant instruction.
	 *
	 * @param opcode
	 *        {@code LDC}
	 * @param value
	 * 		Value to push.
	 */
	public void visitLdc(int opcode, Object value) {
	}

	/**
	 * Visit an integer increment instruction.
	 *
	 * @param opcode
	 *        {@code IINC}
	 * @param index
	 * 		Variable index to increment.
	 * @param incr
	 * 		Value to increment by.
	 */
	public void visitIinc(int opcode, int index, int incr) {
	}

	/**
	 * Visit a variable instruction.
	 *
	 * @param opcode
	 * 		Variable instruction opcode. It is not adjusted to conform to ASM
	 * 		<i>(Use {@link OpcodeUtil#deindexVarOp(int)} for that)</i>.
	 * @param index
	 * 		Index of the local variable.
	 */
	public void visitVar(int opcode, int index) {
	}

	/**
	 * Visit a method invocation instruction.
	 *
	 * @param opcode
	 * 		Method invocation opcode.
	 * @param owner
	 * 		Declaring type of method.
	 * @param name
	 * 		Method name.
	 * @param desc
	 * 		Method descriptor.
	 */
	public void visitMethod(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit a field reference instruction.
	 *
	 * @param opcode
	 * 		Field reference opcode.
	 * @param owner
	 * 		Declaring type of field.
	 * @param name
	 * 		Field name.
	 * @param desc
	 * 		Field descriptor.
	 */
	public void visitField(int opcode, String owner, String name, String desc) {
	}

	/**
	 * Visit an integer push instruction.
	 *
	 * @param opcode
	 * 		Integer push opcode.
	 * @param value
	 * 		Value to push onto the stack.
	 */
	public void visitInt(int opcode, int value) {
	}

	/**
	 * Visit a type instruction.
	 *
	 * @param opcode
	 * 		Type opcode.
	 * @param type
	 * 		Type of the instruction.
	 */
	public void visitType(int opcode, String type) {
	}

	/**
	 * Visit a no-arg instruction.
	 *
	 * @param opcode
	 * 		Instruction opcode.
	 */
	public void visitInsn(int opcode) {
	}
}
