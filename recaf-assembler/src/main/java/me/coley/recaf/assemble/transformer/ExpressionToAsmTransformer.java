package me.coley.recaf.assemble.transformer;

import javassist.*;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.MethodInfo;
import me.coley.recaf.assemble.ast.arch.MethodDefinition;
import me.coley.recaf.assemble.ast.meta.Expression;
import me.coley.recaf.assemble.compiler.JavassistASMTranslator;
import me.coley.recaf.assemble.compiler.JavassistCompilationResult;
import me.coley.recaf.assemble.compiler.JavassistCompiler;
import me.coley.recaf.assemble.util.ClassSupplier;
import me.coley.recaf.util.AccessFlag;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.TryCatchBlockNode;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Visits an {@link Expression} and generates equivalent ASM instructions.
 *
 * @author Matt Coley
 */
public class ExpressionToAsmTransformer {
	private final Map<Expression, TransformResult> resultCache = new HashMap<>();
	private final ClassSupplier classSupplier;
	private final MethodDefinition definition;
	private final Variables variables;
	private final String selfType;

	/**
	 * @param classSupplier
	 * 		Class information supplier.
	 * @param definition
	 * 		Method definition that contains the expression.
	 * @param variables
	 * 		Variable information.
	 * @param selfType
	 * 		The internal type of the class defining the method.
	 */
	public ExpressionToAsmTransformer(ClassSupplier classSupplier, MethodDefinition definition,
									  Variables variables, String selfType) {
		this.classSupplier = classSupplier;
		this.definition = definition;
		this.variables = variables;
		this.selfType = selfType;
	}

	/**
	 * @param expression
	 * 		Expression to visit.
	 *
	 * @return ASM results.
	 *
	 * @throws CannotCompileException
	 * 		When adding the {@link #definition} to a {@link CtClass} fails.
	 * @throws BadBytecode
	 * 		When the generated bytecode is invalid.
	 * @throws IOException
	 * 		When {@link ClassPool#makeClass(InputStream, boolean)} fails.
	 */
	public TransformResult transform(Expression expression) throws CannotCompileException, BadBytecode, IOException {
		// NOTE: Expressions may need to be computed multiple times (analysis, compiling) so caching makes sense...
		// but also because of the incremental feeding of variable data into javassist, we want to be VERY careful
		// not to feed variable generated originating from Javassist back into itself. This leads to some confusing
		// problems where variables are regenerated with the wrong index.
		TransformResult result = resultCache.get(expression);
		if (result != null)
			return result;
		// Transform the expression
		CtClass declaring;
		try {
			// Fetched from supplier
			byte[] selfClassBytes = classSupplier.getClass(selfType);
			InputStream stream = new ByteArrayInputStream(selfClassBytes);
			declaring = ClassPool.getDefault().makeClass(stream, false);
		} catch (ClassNotFoundException ex) {
			// Fallback, make a new class
			declaring = ClassPool.getDefault().makeClass(selfType);
		}
		if (declaring.isFrozen())
			declaring.defrost();
		String name = definition.getName();
		String descriptor = definition.getDesc();
		CtBehavior containerMethod;
		try {
			if (name.equals("<init>")) {
				containerMethod = declaring.getConstructor(descriptor);
			} else {
				containerMethod = declaring.getMethod(name, descriptor);
			}
		} catch (NotFoundException nfe) {
			// Seriously, fuck Javassist for not having a simple "hasX" and instead just throwing
			// unchecked exceptions instead. This is beyond stupid.
			MethodInfo minfo = new MethodInfo(declaring.getClassFile().getConstPool(), name, descriptor);
			containerMethod = CtMethod.make(minfo, declaring);
			declaring.addMethod((CtMethod) containerMethod);
		}
		// Compile with Javassist
		boolean isStatic = AccessFlag.isStatic(definition.getModifiers().value());
		JavassistCompilationResult compilationResult =
				JavassistCompiler.compileExpression(declaring, containerMethod,
						classSupplier, expression, variables, isStatic);
		// Translate to ASM
		JavassistASMTranslator translator = new JavassistASMTranslator();
		translator.visit(declaring, compilationResult.getBytecode().toCodeAttribute());
		result = new TransformResult(translator.getInstructions(), translator.getTryBlocks());
		resultCache.put(expression, result);
		return result;
	}

	/**
	 * Wrapper around ASM generated instructions and other data.
	 */
	public static class TransformResult {
		private final InsnList instructions;
		private final List<TryCatchBlockNode> tryBlocks;

		/**
		 * @param instructions
		 * 		Generated instructions.
		 * @param tryBlocks
		 * 		Generated try-catch blocks.
		 */
		public TransformResult(InsnList instructions, List<TryCatchBlockNode> tryBlocks) {
			this.instructions = instructions;
			this.tryBlocks = tryBlocks;
		}

		/**
		 * @return Generated instructions.
		 */
		public InsnList getInstructions() {
			return instructions;
		}

		/**
		 * @return Generated try-catch blocks.
		 */
		public List<TryCatchBlockNode> getTryBlocks() {
			return tryBlocks;
		}
	}
}
